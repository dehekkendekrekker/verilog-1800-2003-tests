Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2025-12-16T21:52:17+00:00

====== property expr ======
Created Tuesday 16 December 2025

IEEE 1800-2023 Section A.2.10, 16.12

property_expr ::=
	[[sequence_expr]]
	| **strong** ( [[sequence_expr]] )
	| **weak** ( [[sequence_expr]] )
	| ( [[property_expr]] )
	| **not** [[property_expr]]
	| [[property_expr]] **or** [[property_expr]]
	| [[property_expr]] **and** [[property_expr]]
	| [[sequence_expr]] **|->** [[property_expr]]
	| [[sequence_expr]] **|=>** [[property_expr]]
	| **if** ( expression_or_dist ) [[property_expr]] [ **else** [[property_expr]] ]
	| **case** ( expression_or_dist ) [[property_case_item]] { [[property_case_item]] } **endcase**
	| [[sequence_expr]] **#-#** [[property_expr]]
	| [[sequence_expr]] **#=#** [[property_expr]]
	| **nexttime** [[property_expr]]
	| **nexttime** [ constant_expression ] [[property_expr]]
	| **s_nexttime** [[property_expr]]
	| **s_nexttime** [ constant_expression ] [[property_expr]]
	| **always** [[property_expr]]
	| **always** [ [[cycle_delay_const_range_expression]] ] [[property_expr]]
	| **s_always** [ constant_range ] [[property_expr]]
	| **s_eventually** [[property_expr]]
	| **eventually** [ constant_range ] [[property_expr]]
	| **s_eventually** [ [[cycle_delay_const_range_expression]] ] [[property_expr]]
	| [[property_expr]] **until** [[property_expr]]
	| [[property_expr]] **s_until** [[property_expr]]
	| [[property_expr]] **until_with** [[property_expr]]
	| [[property_expr]] **s_until_with** [[property_expr]]
	| [[property_expr]] **implies** [[property_expr]]
	| [[property_expr]] **iff** [[property_expr]]
	| **accept_on** ( expression_or_dist ) [[property_expr]]
	| **reject_on** ( expression_or_dist ) [[property_expr]]
	| **sync_accept_on** ( expression_or_dist ) [[property_expr]]
	| **sync_reject_on** ( expression_or_dist ) [[property_expr]]
	| [[property_instance]]
	| clocking_event [[property_expr]]

===== Category 1: Base forms =====

==== sequence_expr as property ====
A sequence expression used directly as a property.
	a
	a ##1 b
	req ##[1:4] gnt

==== strong(sequence_expr) ====
Strong sequence - must complete.
	strong(req ##[1:$] gnt)

==== weak(sequence_expr) ====
Weak sequence - may or may not complete.
	weak(req ##[1:$] gnt)

==== (property_expr) ====
Parenthesized property.
	(a |-> b)


===== Category 2: Logical operators =====

==== not property_expr ====
Negation.
	not (a && b)
	not (a |-> b)

==== property_expr or property_expr ====
Logical OR.
	(a |-> b) or (c |-> d)

==== property_expr and property_expr ====
Logical AND.
	(a |-> b) and (c |-> d)


===== Category 3: Implication operators =====

==== sequence_expr |-> property_expr (overlapped implication) ====
Antecedent match triggers consequent check same cycle.
	req |-> gnt
	(a ##1 b) |-> c
	a |-> (b ##1 c)

==== sequence_expr |=> property_expr (non-overlapped implication) ====
Antecedent match triggers consequent check next cycle.
	req |=> gnt
	(a ##1 b) |=> (c ##1 d)

==== property_expr implies property_expr ====
Property implication.
	(a |-> b) implies (c |-> d)

==== property_expr iff property_expr ====
Property if-and-only-if.
	(a |-> b) iff (b |-> a)


===== Category 4: Followed-by operators =====

==== sequence_expr #-# property_expr (overlapped followed-by) ====
	a #-# b

==== sequence_expr #=# property_expr (non-overlapped followed-by) ====
	a #=# b


===== Category 5: Temporal operators - nexttime =====

==== nexttime property_expr ====
Property must hold next cycle.
	req |-> nexttime gnt

==== nexttime [n] property_expr ====
Property must hold n cycles later.
	req |-> nexttime[2] gnt

==== s_nexttime property_expr ====
Strong nexttime.
	req |-> s_nexttime gnt

==== s_nexttime [n] property_expr ====
Strong nexttime with offset.
	req |-> s_nexttime[2] gnt


===== Category 6: Temporal operators - always =====

==== always property_expr ====
Property must hold every cycle.
	always valid

==== always [range] property_expr ====
Property must hold within range.
	req |-> always[1:10] busy

==== s_always [range] property_expr ====
Strong always with range.
	s_always[1:10] stable


===== Category 7: Temporal operators - eventually =====

==== eventually [range] property_expr ====
Property must hold at some cycle in range.
	req |-> eventually[1:100] gnt

==== s_eventually property_expr ====
Strong eventually (must complete).
	req |-> s_eventually gnt

==== s_eventually [range] property_expr ====
Strong eventually with range.
	req |-> s_eventually[1:$] gnt


===== Category 8: Temporal operators - until =====

==== property_expr until property_expr ====
First property holds until second becomes true.
	busy until done

==== property_expr s_until property_expr ====
Strong until.
	busy s_until done

==== property_expr until_with property_expr ====
Until (inclusive).
	busy until_with done

==== property_expr s_until_with property_expr ====
Strong until (inclusive).
	busy s_until_with done


===== Category 9: Conditional =====

==== if (expr) property_expr ====
Conditional property without else.
	if (mode) (a |-> b)

==== if (expr) property_expr else property_expr ====
Conditional property with else.
	if (mode) (a |-> b) else (c |-> d)

==== case (expr) property_case_item endcase ====
Case property.
	case(state) 2'b00: idle_prop; 2'b01: run_prop; endcase


===== Category 10: Abort conditions =====

==== accept_on (expr) property_expr ====
Asynchronous accept.
	accept_on(done) req |-> gnt

==== reject_on (expr) property_expr ====
Asynchronous reject.
	reject_on(error) req |-> gnt

==== sync_accept_on (expr) property_expr ====
Synchronous accept.
	sync_accept_on(done) req |-> gnt

==== sync_reject_on (expr) property_expr ====
Synchronous reject.
	sync_reject_on(error) req |-> gnt


===== Category 11: Instance and clocking =====

==== property_instance ====
Named property instantiation.
	my_property(a, b)

==== clocking_event property_expr ====
Property with explicit clock.
	@(posedge clk) a |-> b


===== Backlinks =====
[[assert_property_statement]]
[[property_actual_arg]]
[[property_case_item]]
[[property_expr]]
[[property_spec]]
